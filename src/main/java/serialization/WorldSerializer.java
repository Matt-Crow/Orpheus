package serialization;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Base64;
import world.World;
import world.WorldContent;

/**
 * This class handles all of the serialization / de-serialization of a World
 * 
 * @author Matt Crow <mattcrow19@gmail.com>
 */
public class WorldSerializer {
    private final World world;
    
    public WorldSerializer(World world){
        this.world = world;
    }
    
    /**
     * Takes the serializable content of the world, then returns it as a string.
     * 
     * @return the serialized content of this world 
     * @throws java.lang.Exception if the World cannot be serialized
     */
    public String serializeToString() {
        WorldContent content = world.getSerializableContent();
        return serializeToString(content);
    }
    
    /**
     * Serializes an Object as a string so that it can
     * be used as the body of a ServerMessage
     * 
     * @param obj the object to serialize
     * @return the serialized version of the given Object
     */
    private String serializeToString(Object obj) {
        String ret = "";
        try(
                ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
                ObjectOutputStream objOut = new ObjectOutputStream(byteOut);
        ){
            objOut.writeObject(obj);
            ret = Base64.getEncoder().encodeToString(byteOut.toByteArray());
        } catch(IOException ex){
            throw new RuntimeException(ex);
        } catch(StackOverflowError ex){
            System.err.printf("Stack over on %s%n", obj);
            throw new RuntimeException(ex);
        }
        return ret;
    }
    
    /**
     * Note that this method updates the attached world object, so any objects
     * referencing the world passed to this object's constructor needn't worry
     * about manually updating their copies, as all the references point to the
     * newly updated world.
     * 
     * @param s the content of a world, as generated by 
     *          WorldSerializer::serializeToString 
     */
    public void deserialize(String s){
        Object deserialized = fromSerializedString(s);
        if(deserialized instanceof WorldContent){
            WorldContent newContent = (WorldContent)deserialized;
            world.setSerializableContent(newContent);
        }
    }
    
    /**
     * Converts a String generated from serializeToString,
     * and de-serializes it into a copy of that original Object, 
     * barring Transient fields.
     * 
     * @param s a string variant of an object stream serialization of an object
     * @return a copy of the object which was serialized into a string
     */
    public static Object fromSerializedString(String s){
        Object ret = null;
        byte[] byteData = Base64.getDecoder().decode(s);
        try (ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(byteData))) {
            ret = objIn.readObject(); // bad here
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
        return ret;
    }
}
